/**
 * @Author: spruce
 * @Date: 2023-04-10 16:29
 * @Desc: sql gen Model 模板
 */

package sqlgen

const NotEditMark = `
// Code generated by SqlGen. DO NOT EDIT.
`

const Header = `
package {{.PackageName}}

import (
	"context"
	"time"

	"gorm.io/gorm"
)

`

const BaseRepoMethod = NotEditMark + Header + `

var  _ {{.InterfaceName}}Repo = (*default{{.StructName}}Repo)(nil)

const TableName{{.StructName}} = "{{.TableName}}"

type (
	{{.InterfaceName}}Repo interface {
		Insert(ctx context.Context,data *{{.StructName}}) ({{.PrimaryKeyType}}, error)
		BatchInsert(ctx context.Context,list []*{{.StructName}}) ([]{{.PrimaryKeyType}}, error)

		FindOne(ctx context.Context, id {{.PrimaryKeyType}}) (*{{.StructName}}, error)

		Update(ctx context.Context, newData *{{.StructName}}, column []string)  (int64, error)
		UpdateColumns(ctx context.Context, id {{.PrimaryKeyType}}, newData map[string]any)  (int64, error)

		SoftDelete(ctx context.Context,ids []{{.PrimaryKeyType}}) error
		Delete(ctx context.Context,ids []{{.PrimaryKeyType}}) error

	}

	// {{.StructName}} {{.StructComment}}
	{{.StructName}} struct {
		{{range .Fields}}
            {{.Name}} {{.Type}} ` + "`{{.Tags}}` {{.CommentTag}}" +
	`{{end}}
    }

	default{{.StructName}}Repo struct {
		*Conn
		model *{{.StructName}}
	}
)


func (*{{.StructName}}) TableName() string {
	return TableName{{.StructName}}
}

func new{{.StructName}}(c *Conn) *default{{.StructName}}Repo {
	return &default{{.StructName}}Repo{
		Conn:   c,
		model:    &{{.StructName}}{},
	}
}

func (r *default{{.StructName}}Repo) Insert(ctx context.Context,data *{{.StructName}}) ({{.PrimaryKeyType}}, error) {
    data.Id = 0
	err := r.WithContext(ctx).Create(data).Error
	if err != nil {
		return 0,err
	}
	return data.Id,nil
}

func (r *default{{.StructName}}Repo) BatchInsert(ctx context.Context,list []*{{.StructName}}) ([]{{.PrimaryKeyType}}, error) {
	err := r.WithContext(ctx).Create(list).Error
	if err != nil {
		return nil,err
	}
    ids := make([]{{.PrimaryKeyType}}, len(list))
	for i, v := range list {
		ids[i] = v.Id
	}
	return ids,nil
}


func (r *default{{.StructName}}Repo) FindOne(ctx context.Context,id {{.PrimaryKeyType}}) (*{{.StructName}}, error) {
    result:= &{{.StructName}}{}
	err := r.WithContext(ctx).Where(" id = ? ", id).First(result).Error
    if  err != nil {
		return nil, err
	}
	return result, nil
}

func (r *default{{.StructName}}Repo) Update(ctx context.Context,newData *{{.StructName}}, column []string)  (int64, error)  {
	engine := r.WithContext(ctx).Model(r.model)
	if len(column) > 0 {
		engine = engine.Select(column)
	}
	result := engine.Omit("id").Where(" id = ? ", newData.Id).Updates(newData)
	return result.RowsAffected, result.Error
}

func (r *default{{.StructName}}Repo) UpdateColumns(ctx context.Context,id {{.PrimaryKeyType}}, newData map[string]any)  (int64, error)  {
	result := r.WithContext(ctx).Model(r.model).Where(" id = ? ", id).Updates(newData)
	return result.RowsAffected, result.Error
}


func (r *default{{.StructName}}Repo) SoftDelete(ctx context.Context,ids []{{.PrimaryKeyType}}) error {
	err :=  r.WithContext(ctx).Where(" id  IN (?)  ", ids).Delete(r.model).Error
	return err
}

func (r *default{{.StructName}}Repo) Delete(ctx context.Context, ids []{{.PrimaryKeyType}}) error {
	err := r.WithContext(ctx).Where(" id  IN (?)  ", ids).Unscoped().Delete(r.model).Error
	return err
}

`

const InterfaceMethod = `
package {{.PackageName}}

import (
	"context"
)

//go:generate mockgen -source=./{{.InterfaceName}}.go -destination=../../test/mocks/repository/mysql/{{.InterfaceName}}.go  -package mock_repo_mysql -aux_files mysql=./{{.InterfaceName}}_gen.go

var _ {{.StructName}}Repo = (*custom{{.StructName}}Repo)(nil)

type (
	{{.StructName}}Repo interface {
		{{.InterfaceName}}Repo
	}


	custom{{.StructName}}Repo struct {
		*default{{.StructName}}
	}
)

func New{{.StructName}}Repo(c *Conn) {{.StructName}}Repo {
	return &custom{{.StructName}}Repo{
		default{{.StructName}}: new{{.StructName}}(c),
	}
}


`
